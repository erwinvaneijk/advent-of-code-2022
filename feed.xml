<?xml version="1.0" encoding="UTF-16"?>
<!--This file generated by build script at ./Build.hs in solutions repository-->
<rss version="2.0">
  <channel>
    <title>Justin Le's Advent of Code 2021 Reflections</title>
    <description>Reflections for my Advent of Code solutions as I try to solve them all in fun ways using Haskell!</description>
    <link>https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md</link>
    <copyright>Copyright 2021 Justin Le</copyright>
    <language>en-us</language>
    <lastBuildDate>Thu,  2 Dec 2021 22:50:04 EST</lastBuildDate>
    <managingEditor>justin@jle.im</managingEditor>
    <pubDate>Thu,  2 Dec 2021 22:50:04 EST</pubDate>
    <webMaster>justin@jle.im</webMaster>
    <generator>Shake + Template</generator>
    <item>
      <title>Day 2</title>
      <description>&lt;h2 id=&quot;day-2&quot;&gt;Day 2&lt;/h2&gt;
&lt;!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
--&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://adventofcode.com/2021/day/2&quot;&gt;Prompt&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day02.hs&quot;&gt;Code&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day02.html&quot;&gt;Rendered&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day02.md&quot;&gt;Standalone Reflection Page&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Day 2 has a satisfying “unified” solution for both parts that can be derived from group theory! The general group (or monoid) design pattern that I’ve gone over &lt;a href=&quot;https://blog.jle.im/entries/series/+advent-of-code.html&quot;&gt;in many Advent of Code blog posts&lt;/a&gt; is that we can think of our “final action” as simply a “squishing” of individual smaller actions. The revelation is that our individual smaller actions are “combinable” to yield something of the &lt;em&gt;same type&lt;/em&gt;, so solving the puzzle is generating all of the smaller actions repeatedly combining them to yield the final action.&lt;/p&gt;
&lt;p&gt;In both of these parts, we can think of squishing a bunch of small actions (&lt;code&gt;forward&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;) into a mega-action, which represents the final trip as one big step. So here is our general solver:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;-- | A type for x-y coordinates/2d vectors&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; pX ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;ot&quot;&gt; pY ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;day02&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; r&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r)            &lt;span class=&quot;co&quot;&gt;-- ^ construct a forward action&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r)            &lt;span class=&quot;co&quot;&gt;-- ^ construct an up/down action&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Point&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;-- ^ how to apply an action to a point&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Point&lt;/span&gt;                 &lt;span class=&quot;co&quot;&gt;-- ^ the final point&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;day02 mkForward mkUpDown applyAct &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      (&lt;span class=&quot;ot&quot;&gt;`applyAct`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)             &lt;span class=&quot;co&quot;&gt;-- get the answer by applying from 0,0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;op&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;foldMap&lt;/span&gt; (parseAsDir &lt;span class=&quot;op&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;words&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- convert each line into the action and merge&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;op&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lines&lt;/span&gt;                          &lt;span class=&quot;co&quot;&gt;-- split up lines&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-16&quot;&gt;&lt;a href=&quot;#cb1-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    parseAsDir (dir&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;n&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; dir &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-17&quot;&gt;&lt;a href=&quot;#cb1-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;st&quot;&gt;&amp;quot;forward&amp;quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mkForward amnt&lt;/span&gt;
&lt;span id=&quot;cb1-18&quot;&gt;&lt;a href=&quot;#cb1-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;st&quot;&gt;&amp;quot;down&amp;quot;&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mkUpDown amnt&lt;/span&gt;
&lt;span id=&quot;cb1-19&quot;&gt;&lt;a href=&quot;#cb1-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;st&quot;&gt;&amp;quot;up&amp;quot;&lt;/span&gt;      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; mkUpDown (&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;amnt)&lt;/span&gt;
&lt;span id=&quot;cb1-20&quot;&gt;&lt;a href=&quot;#cb1-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-21&quot;&gt;&lt;a href=&quot;#cb1-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        amnt &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And there we have it! A solver for both parts 1 and 2. Now we just need to pick the Monoid :)&lt;/p&gt;
&lt;p&gt;For part 1, the choice of monoid is simple: our final action is a translation by a vector, so it makes sense that the intermediate actions would be vectors as well – composing actions means adding those vectors together.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; dX ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;,&lt;span class=&quot;ot&quot;&gt; dY ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx dy &lt;span class=&quot;op&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx&amp;#39; dy&amp;#39; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; (dx &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dx&amp;#39;) (dy &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dy&amp;#39;)&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;mempty&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;day02a ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;day02a &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; day02&lt;/span&gt;
&lt;span id=&quot;cb2-10&quot;&gt;&lt;a href=&quot;#cb2-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\dx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- forward is just a horizontal vector&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-11&quot;&gt;&lt;a href=&quot;#cb2-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\dy &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; dy)   &lt;span class=&quot;co&quot;&gt;-- up/down is a vertical vector&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-12&quot;&gt;&lt;a href=&quot;#cb2-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\(&lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx dy) (&lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; x0 y0) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; (x0 &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dx) (y0 &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dy))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Part 2 is a little trickier because we have to keep track of dx, dy &lt;em&gt;and&lt;/em&gt; aim. So we can think of our action as manipulating a &lt;code&gt;Point&lt;/code&gt; as well as an &lt;code&gt;Aim&lt;/code&gt;, and combining them together.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; (a &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;mempty&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So our “action” looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Part2Action&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P2A&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; p2Vector ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt;,&lt;span class=&quot;ot&quot;&gt; p2Aim ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, it’s not exactly obvious how to turn this into a monoid. How do we combine two &lt;code&gt;Part2Action&lt;/code&gt;s to create a new one, in a way that respects the logic of part 2? Simply adding them point-wise does not do the trick, because we have to somehow also get the &lt;code&gt;Aim&lt;/code&gt; to factor into the new y value.&lt;/p&gt;
&lt;p&gt;Group theory to the rescue! Using the &lt;a href=&quot;https://hackage.haskell.org/package/monoid-extras-0.6.1&quot;&gt;monoid-extras&lt;/a&gt; library, we can can say that &lt;code&gt;Aim&lt;/code&gt; encodes a “vector transformer”. Applying an aim means adding the dy value by the aim value multiplied the dx component.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Action&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    act (&lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; moveDownByAimFactor&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        moveDownByAimFactor (&lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx dy) &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx (dy &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; dx)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because of this, we can now pair together &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Aim&lt;/code&gt; as a &lt;a href=&quot;https://hackage.haskell.org/package/monoid-extras-0.6.1/docs/Data-Monoid-SemiDirectProduct.html&quot;&gt;semi-direct product&lt;/a&gt;: If we pair up our monoid (&lt;code&gt;Vector&lt;/code&gt;) with a “point transformer” (&lt;code&gt;Aim&lt;/code&gt;), then &lt;code&gt;Semi Vector Aim&lt;/code&gt; is a monoid that contains both (like our &lt;code&gt;Part2Action&lt;/code&gt; above) but also provides a &lt;code&gt;Monoid&lt;/code&gt; instance that “does the right thing” (adds vector, adds aim, and also makes sure the aim action gets applied correctly when adding vectors) thanks to group theory.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;-- constructors/deconstructors that monoid-extras gives us&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;inject ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semi&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;embed  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semi&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;untag  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semi&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;day02b ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-7&quot;&gt;&lt;a href=&quot;#cb6-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;day02b &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; day02&lt;/span&gt;
&lt;span id=&quot;cb6-8&quot;&gt;&lt;a href=&quot;#cb6-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\dx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; inject &lt;span class=&quot;op&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- forward just contributs a vector motion&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-9&quot;&gt;&lt;a href=&quot;#cb6-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\a  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; embed  &lt;span class=&quot;op&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Aim&lt;/span&gt; a )   &lt;span class=&quot;co&quot;&gt;-- up/down just adjusts the aim&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-10&quot;&gt;&lt;a href=&quot;#cb6-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    (\sdp (&lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; x0 y0) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-11&quot;&gt;&lt;a href=&quot;#cb6-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt; dx dy &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; untag sdp&lt;/span&gt;
&lt;span id=&quot;cb6-12&quot;&gt;&lt;a href=&quot;#cb6-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; (x0 &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dx) (y0 &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; dy)&lt;/span&gt;
&lt;span id=&quot;cb6-13&quot;&gt;&lt;a href=&quot;#cb6-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it, we’re done, thanks to the power of group theory! We identified that our final monoid must somehow contain both components (&lt;code&gt;Vector&lt;/code&gt;, and &lt;code&gt;Aim&lt;/code&gt;), but did not know how the two could come together to form a mega-monoid of both. However, because we saw that &lt;code&gt;Aim&lt;/code&gt; also gets accumulated while also acting as a “point transformer”, we can describe how it transforms points (with the &lt;code&gt;Action&lt;/code&gt; instance) and so we can use &lt;code&gt;Semi&lt;/code&gt; (semi-direct product) to encode our action with a &lt;code&gt;Monoid&lt;/code&gt; instance that does the right thing.&lt;/p&gt;
&lt;p&gt;What was the point of this? Well, we were able to unify both parts 1 and 2 to be solved in the same overall method, just by picking a different monoid for each part. With only two parts, it might not seem that worth it to abstract, but maybe if there were more we could experiment with what other neat monoids we could express our solution as! But, a major advantage we reap now is that, because each action combines into other actions (associatively), we could do all of this in parallel! If our list of actions was very long, we could distribute the work over multiple cores or computers and re-combine like a map-reduce. There’s just something very satisfying about having the “final action” be of the same type as our intermediate actions. With that revelation, we open the door to the entire field of monoid-based optimizations and pre-made algorithms (like &lt;code&gt;Semi&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;(Thanks to &lt;code&gt;mniip&lt;/code&gt; in libera irc’s &lt;em&gt;#adventofcode&lt;/em&gt; channel for helping me express this in terms of a semi-direct product! My original attempt used a 4x4 matrix that ended up doing the same thing after some symbolic analysis.)&lt;/p&gt;
&lt;p&gt;(Thanks too to @lysxia on twitter for pointing out a nicer way of interpreting the action in terms of how it acts on points!)&lt;/p&gt;
&lt;h3 id=&quot;day-2-benchmarks&quot;&gt;Day 2 Benchmarks&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; Day 02a
benchmarking...
time                 8.030 μs   (7.348 μs .. 8.777 μs)
                     0.955 R²   (0.936 R² .. 0.993 R²)
mean                 7.800 μs   (7.516 μs .. 8.666 μs)
std dev              1.719 μs   (936.6 ns .. 3.161 μs)
variance introduced by outliers: 97% (severely inflated)

* parsing and formatting times excluded

&amp;gt;&amp;gt; Day 02b
benchmarking...
time                 1.710 ms   (1.616 ms .. 1.830 ms)
                     0.964 R²   (0.929 R² .. 0.987 R²)
mean                 1.730 ms   (1.673 ms .. 1.792 ms)
std dev              215.9 μs   (168.1 μs .. 321.3 μs)
variance introduced by outliers: 79% (severely inflated)&lt;/code&gt;&lt;/pre&gt;
</description>
      <link>https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md#day-2</link>
      <pubDate>Thu,  2 Dec 2021 01:00:00 EST</pubDate>
    </item>

    <item>
      <title>Day 1</title>
      <description>&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;/h2&gt;
&lt;!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
--&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://adventofcode.com/2021/day/1&quot;&gt;Prompt&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day01.hs&quot;&gt;Code&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day01.html&quot;&gt;Rendered&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day01.md&quot;&gt;Standalone Reflection Page&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As a simple data processing thing, this one shines pretty well in Haskell :)&lt;/p&gt;
&lt;p&gt;Assuming we have a list, we can get the consecutive items with a combination of &lt;code&gt;zipWith&lt;/code&gt; and &lt;code&gt;drop&lt;/code&gt;. Then we can just count how many pairs of items match the predicate (strictly increasing):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;countIncreasesPart1 ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;countIncreasesPart1 xs &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;zipWith&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;) xs (&lt;span class=&quot;fu&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; xs)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yes, &lt;code&gt;filter (== True)&lt;/code&gt; is the same as &lt;code&gt;filter id&lt;/code&gt;, but it’s a bit easier to read this way :)&lt;/p&gt;
&lt;p&gt;Remember that if &lt;code&gt;xs&lt;/code&gt; is &lt;code&gt;[2,4,6,5]&lt;/code&gt;, then &lt;code&gt;drop 1 xs&lt;/code&gt; is &lt;code&gt;[4,6,5]&lt;/code&gt;, and so &lt;code&gt;zip xs (drop 1 xs)&lt;/code&gt; is &lt;code&gt;[(2,4), (4,6), (6,5)]&lt;/code&gt; So &lt;code&gt;zipWith (&amp;lt;) xs (drop 1 xs)&lt;/code&gt; is &lt;code&gt;[True, True, False]&lt;/code&gt;. So counting all of the &lt;code&gt;True&lt;/code&gt; items yields the right answer!&lt;/p&gt;
&lt;p&gt;Part 2 is very similar, but we need to check if items &lt;em&gt;three&lt;/em&gt; positions apart are increasing. That’s because for each window, the sum of the window is increasing if the new item gained is bigger than the item that was just lost. So for an example like &lt;code&gt;[3,5,6,4,7,8]&lt;/code&gt;, as we move from &lt;code&gt;[3,5,6]&lt;/code&gt; to &lt;code&gt;[5,6,4]&lt;/code&gt;, we only need to check if &lt;code&gt;4&lt;/code&gt; is greater than &lt;code&gt;3&lt;/code&gt;. So we only need to compare 4 and 3, 7 and 5, and then 8 and 6.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;countIncreasesPart2 ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;countIncreasesPart2 xs &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;zipWith&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;) xs (&lt;span class=&quot;fu&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; xs)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We just need to replace &lt;code&gt;drop 1 xs&lt;/code&gt; with &lt;code&gt;drop 3 xs&lt;/code&gt; to compare three-away items.&lt;/p&gt;
&lt;p&gt;Anyway the parsing in Haskell is straightforward, at least – we can just do &lt;code&gt;map read . lines&lt;/code&gt;, to split our input into lines and then map &lt;code&gt;read :: String -&amp;gt; Int&lt;/code&gt; over each line. Ta dah! Fun start to the year :)&lt;/p&gt;
&lt;h3 id=&quot;day-1-benchmarks&quot;&gt;Day 1 Benchmarks&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; Day 01a
benchmarking...
time                 26.81 μs   (26.45 μs .. 27.29 μs)
                     0.996 R²   (0.991 R² .. 1.000 R²)
mean                 26.75 μs   (26.43 μs .. 27.57 μs)
std dev              1.478 μs   (130.1 ns .. 2.625 μs)
variance introduced by outliers: 62% (severely inflated)

* parsing and formatting times excluded

&amp;gt;&amp;gt; Day 01b
benchmarking...
time                 27.02 μs   (25.16 μs .. 28.74 μs)
                     0.966 R²   (0.956 R² .. 0.979 R²)
mean                 26.40 μs   (25.02 μs .. 27.78 μs)
std dev              4.752 μs   (3.640 μs .. 6.699 μs)
variance introduced by outliers: 95% (severely inflated)

* parsing and formatting times excluded&lt;/code&gt;&lt;/pre&gt;
</description>
      <link>https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md#day-1</link>
      <pubDate>Wed,  1 Dec 2021 01:00:00 EST</pubDate>
    </item>

  </channel>
</rss>
