<?xml version="1.0" encoding="UTF-16"?>
<!--This file generated by build script at ./Build.hs in solutions repository-->
<rss version="2.0">
  <channel>
    <title>Justin Le's Advent of Code 2021 Reflections</title>
    <description>Reflections for my Advent of Code solutions as I try to solve them all in fun ways using Haskell!</description>
    <link>https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md</link>
    <copyright>Copyright 2021 Justin Le</copyright>
    <language>en-us</language>
    <lastBuildDate>Wed,  1 Dec 2021 02:30:03 EST</lastBuildDate>
    <managingEditor>justin@jle.im</managingEditor>
    <pubDate>Wed,  1 Dec 2021 02:30:03 EST</pubDate>
    <webMaster>justin@jle.im</webMaster>
    <generator>Shake + Template</generator>
    <item>
      <title>Day 1</title>
      <description>&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;/h2&gt;
&lt;!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
--&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://adventofcode.com/2021/day/1&quot;&gt;Prompt&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day01.hs&quot;&gt;Code&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day01.html&quot;&gt;Rendered&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&quot;https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day01.md&quot;&gt;Standalone Reflection Page&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As a simple data processing thing, this one shines pretty well in Haskell :)&lt;/p&gt;
&lt;p&gt;Assuming we have a list, we can get the consecutive items with a combination of &lt;code&gt;zipWith&lt;/code&gt; and &lt;code&gt;drop&lt;/code&gt;. Then we can just count how many pairs of items match the predicate (strictly increasing):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;countIncreasesPart1 ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;countIncreasesPart1 xs &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;zipWith&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;) xs (&lt;span class=&quot;fu&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; xs)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yes, &lt;code&gt;filter (== True)&lt;/code&gt; is the same as &lt;code&gt;filter id&lt;/code&gt;, but it’s a bit easier to read this way :)&lt;/p&gt;
&lt;p&gt;Remember that if &lt;code&gt;xs&lt;/code&gt; is &lt;code&gt;[2,4,6,5]&lt;/code&gt;, then &lt;code&gt;drop 1 xs&lt;/code&gt; is &lt;code&gt;[4,6,5]&lt;/code&gt;, and so &lt;code&gt;zip xs (drop 1 xs)&lt;/code&gt; is &lt;code&gt;[(2,4), (4,6), (6,5)]&lt;/code&gt; So &lt;code&gt;zipWith (&amp;lt;) xs (drop 1 xs)&lt;/code&gt; is &lt;code&gt;[True, True, False]&lt;/code&gt;. So counting all of the &lt;code&gt;True&lt;/code&gt; items yields the right answer!&lt;/p&gt;
&lt;p&gt;Part 2 is very similar, but we need to check if items &lt;em&gt;three&lt;/em&gt; positions apart are increasing. That’s because for each window, the sum of the window is increasing if the new item gained is bigger than the item that was just lost. So for an example like &lt;code&gt;[3,5,6,4,7,8]&lt;/code&gt;, as we move from &lt;code&gt;[3,5,6]&lt;/code&gt; to &lt;code&gt;[5,6,4]&lt;/code&gt;, we only need to check if &lt;code&gt;4&lt;/code&gt; is greater than &lt;code&gt;3&lt;/code&gt;. So we only need to compare 4 and 3, 7 and 5, and then 8 and 6.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;countIncreasesPart2 ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;countIncreasesPart2 xs &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;zipWith&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;) xs (&lt;span class=&quot;fu&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; xs)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We just need to replace &lt;code&gt;drop 1 xs&lt;/code&gt; with &lt;code&gt;drop 3 xs&lt;/code&gt; to compare three-away items.&lt;/p&gt;
&lt;p&gt;Anyway the parsing in Haskell is straightforward, at least – we can just do &lt;code&gt;map read . lines&lt;/code&gt;, to split our input into lines and then map &lt;code&gt;read :: String -&amp;gt; Int&lt;/code&gt; over each line. Ta dah! Fun start to the year :)&lt;/p&gt;
&lt;h3 id=&quot;day-1-benchmarks&quot;&gt;Day 1 Benchmarks&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; Day 01a
benchmarking...
time                 26.81 μs   (26.45 μs .. 27.29 μs)
                     0.996 R²   (0.991 R² .. 1.000 R²)
mean                 26.75 μs   (26.43 μs .. 27.57 μs)
std dev              1.478 μs   (130.1 ns .. 2.625 μs)
variance introduced by outliers: 62% (severely inflated)

* parsing and formatting times excluded

&amp;gt;&amp;gt; Day 01b
benchmarking...
time                 27.02 μs   (25.16 μs .. 28.74 μs)
                     0.966 R²   (0.956 R² .. 0.979 R²)
mean                 26.40 μs   (25.02 μs .. 27.78 μs)
std dev              4.752 μs   (3.640 μs .. 6.699 μs)
variance introduced by outliers: 95% (severely inflated)

* parsing and formatting times excluded&lt;/code&gt;&lt;/pre&gt;
</description>
      <link>https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md#day-1</link>
      <pubDate>Wed,  1 Dec 2021 01:00:00 EST</pubDate>
    </item>

  </channel>
</rss>
