Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

*[2016][]* / *[2017][]* / *[2018][]* / *[2019][]* / *[2020][]* / *2021*

[2016]: https://github.com/mstksg/advent-of-code-2016/blob/master/reflections.md
[2017]: https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md
[2018]: https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md
[2019]: https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md
[2020]: https://github.com/mstksg/advent-of-code-2020/blob/master/reflections.md

[Available as an RSS Feed][rss]

[rss]: http://feeds.feedburner.com/jle-advent-of-code-2021

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3) *(no reflection yet)*
* [Day 4](#day-4) *(no reflection yet)*

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]* / *[Rendered][d01h]* / *[Standalone Reflection Page][d01r]*

[d01p]: https://adventofcode.com/2021/day/1
[d01g]: https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day01.hs
[d01h]: https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day01.html
[d01r]: https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day01.md

As a simple data processing thing, this one shines pretty well in Haskell :)

Assuming we have a list, we can get the consecutive items with a combination of
`zipWith` and `drop`.  Then we can just count how many pairs of items match the
predicate (strictly increasing):

```haskell
countIncreasesPart1 :: [Int] -> Int
countIncreasesPart1 xs = length (filter (== True) (zipWith (<) xs (drop 1 xs)))
```

Yes, `filter (== True)` is the same as `filter id`, but it's a bit easier to
read this way :)

Remember that if `xs` is `[2,4,6,5]`, then `drop 1 xs` is `[4,6,5]`, and so
`zip xs (drop 1 xs)` is `[(2,4), (4,6), (6,5)]`  So `zipWith (<) xs (drop 1
xs)` is `[True, True, False]`.  So counting all of the `True` items yields the
right answer!

Part 2 is very similar, but we need to check if items *three* positions apart
are increasing.  That's because for each window, the sum of the window is
increasing if the new item gained is bigger than the item that was just lost.
So for an example like `[3,5,6,4,7,8]`, as we move from `[3,5,6]` to `[5,6,4]`,
we only need to check if `4` is greater than `3`.  So we only need to compare 4
and 3, 7 and 5, and then 8 and 6.

```haskell
countIncreasesPart2 :: [Int] -> Int
countIncreasesPart2 xs = length (filter (== True) (zipWith (<) xs (drop 3 xs)))
```

We just need to replace `drop 1 xs` with `drop 3 xs` to compare three-away
items.

Anyway the parsing in Haskell is straightforward, at least -- we can just do
`map read . lines`, to split our input into lines and then map `read :: String
-> Int` over each line.  Ta dah!  Fun start to the year :)


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 26.81 μs   (26.45 μs .. 27.29 μs)
                     0.996 R²   (0.991 R² .. 1.000 R²)
mean                 26.75 μs   (26.43 μs .. 27.57 μs)
std dev              1.478 μs   (130.1 ns .. 2.625 μs)
variance introduced by outliers: 62% (severely inflated)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 27.02 μs   (25.16 μs .. 28.74 μs)
                     0.966 R²   (0.956 R² .. 0.979 R²)
mean                 26.40 μs   (25.02 μs .. 27.78 μs)
std dev              4.752 μs   (3.640 μs .. 6.699 μs)
variance introduced by outliers: 95% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]* / *[Rendered][d02h]* / *[Standalone Reflection Page][d02r]*

[d02p]: https://adventofcode.com/2021/day/2
[d02g]: https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day02.hs
[d02h]: https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day02.html
[d02r]: https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day02.md

Day 2 has a satisfying "unified" solution for both parts that can be derived
from group theory!  The general group (or monoid) design pattern that I've gone
over [in many Advent of Code blog posts][day2-monoid-posts] is that we can
think of our "final action" as simply a "squishing" of individual smaller
actions.  The revelation is that our individual smaller actions are
"combinable" to yield something of the *same type*, so solving the puzzle is
generating all of the smaller actions repeatedly combining them to yield the
final action.

[day2-monoid-posts]: https://blog.jle.im/entries/series/+advent-of-code.html

In both of these parts, we can think of squishing a bunch of small actions
(`forward`, `up`, `down`) into a mega-action, which represents the final trip
as one big step.  So here is our general solver:

```haskell
-- | A type for x-y coordinates/2d vectors
data Point = P { pX :: Int, pY :: Int }

day02
    :: Monoid r
    => (Int -> r)            -- ^ construct a forward action
    -> (Int -> r)            -- ^ construct an up/down action
    -> (r -> Point -> Point) -- ^ how to apply an action to a point
    -> String
    -> Point                 -- ^ the final point
day02 mkForward mkUpDown applyAct =
      (`applyAct` P 0 0)             -- get the answer by applying from 0,0
    . foldMap (parseAsDir . words)   -- convert each line into the action and merge
    . lines                          -- split up lines
  where
    parseAsDir (dir:n:_) = case dir of
        "forward" -> mkForward amnt
        "down"    -> mkUpDown amnt
        "up"      -> mkUpDown (-amnt)
      where
        amnt = read n
```

And there we have it!  A solver for both parts 1 and 2.  Now we just need to
pick the Monoid :)

For part 1, the choice of monoid is simple: our final action is a translation
by a vector, so it makes sense that the intermediate actions would be vectors as
well -- composing actions means adding those vectors together.

```haskell
data Vector = V { dX :: Int, dY :: Int }

instance Semigroup Vector where
    V dx dy <> V dx' dy' = V (dx + dx') (dy + dy')
instance Monoid Vector where
    mempty = V 0 0

day02a :: String -> Int
day02a = day02
    (\dx -> V dx 0)   -- forward is just a horizontal vector
    (\dy -> V 0 dy)   -- up/down is a vertical vector
    (\(V dx dy) (P x0 y0) -> P (x0 + dx) (y0 + dy))
```

Part 2 is a little trickier because we have to keep track of dx, dy *and* aim.
So we can think of our action as manipulating a `Point` as well as an `Aim`,
and combining them together.

```haskell
newtype Aim = Aim Int

instance Semigroup Aim where
    Aim a <> Aim b = Aim (a + b)
instance Monoid Aim where
    mempty = Aim 0
```

So our "action" looks like:

```haskell
data Part2Action = P2A { p2Vector :: Vector, p2Aim :: Aim }
```

However, it's not exactly obvious how to turn this into a monoid.  How do we
combine two `Part2Action`s to create a new one, in a way that respects the
logic of part 2?  Simply adding them point-wise does not do the trick, because
we have to somehow also get the `Aim` to factor into the new y value.

Group theory to the rescue!  Using the [monoid-extras][] library, we can
can say that `Aim` encodes a "vector transformer".  Applying an aim means adding
the dy value by the aim value multiplied the dx component.

[monoid-extras]: https://hackage.haskell.org/package/monoid-extras-0.6.1

```haskell
instance Action Aim Vector where
    act (Aim a) = moveDownByAimFactor
      where
        moveDownByAimFactor (V dx dy) = V dx (dy + a * dx)
```

Because of this, we can now pair together `Vector` and `Aim` as a [semi-direct
product][]: If we pair up our monoid (`Vector`) with a "point transformer"
(`Aim`), then `Semi Vector Aim` is a monoid that contains both (like our
`Part2Action` above) but also provides a `Monoid` instance that "does the right
thing" (adds vector, adds aim, and also makes sure the aim action gets applied
correctly when adding vectors) thanks to group theory.

[semi-direct product]: https://hackage.haskell.org/package/monoid-extras-0.6.1/docs/Data-Monoid-SemiDirectProduct.html

```haskell
-- constructors/deconstructors that monoid-extras gives us
inject :: Vector -> Semi Vector Aim
embed  :: Aim    -> Semi Vector Aim
untag  :: Semi Vector Aim -> Vector

day02b :: String -> Int
day02b = day02
    (\dx -> inject $ V dx 0)   -- forward just contributs a vector motion
    (\a  -> embed  $ Aim a )   -- up/down just adjusts the aim
    (\sdp (P x0 y0) ->
        let V dx dy = untag sdp
        in  P (x0 + dx) (y0 + dy)
    )
```

And that's it, we're done, thanks to the power of group theory!  We identified
that our final monoid must somehow contain both components (`Vector`, and
`Aim`), but did not know how the two could come together to form a mega-monoid
of both.  However, because we saw that `Aim` also gets accumulated while also
acting as a "point transformer", we can describe how it transforms points (with
the `Action` instance) and so we can use `Semi` (semi-direct product) to encode
our action with a `Monoid` instance that does the right thing.

What was the point of this?  Well, we were able to unify both parts 1 and 2 to
be solved in the same overall method, just by picking a different monoid for
each part.  With only two parts, it might not seem that worth it to abstract,
but maybe if there were more we could experiment with what other neat monoids
we could express our solution as!  But, a major advantage we reap now is that,
because each action combines into other actions (associatively), we could do
all of this in parallel!  If our list of actions was very long, we could
distribute the work over multiple cores or computers and re-combine like a
map-reduce.  There's just something very satisfying about having the "final
action" be of the same type as our intermediate actions.  With that
revelation, we open the door to the entire field of monoid-based optimizations
and pre-made algorithms (like `Semi`)

(Thanks to `mniip` in libera irc's *#adventofcode* channel for helping me
express this in terms of a semi-direct product! My original attempt used a 4x4
matrix that ended up doing the same thing after some symbolic analysis.)

(Thanks too to \@lysxia on twitter for pointing out a nicer way of interpreting
the action in terms of how it acts on points!)


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 8.030 μs   (7.348 μs .. 8.777 μs)
                     0.955 R²   (0.936 R² .. 0.993 R²)
mean                 7.800 μs   (7.516 μs .. 8.666 μs)
std dev              1.719 μs   (936.6 ns .. 3.161 μs)
variance introduced by outliers: 97% (severely inflated)

* parsing and formatting times excluded

>> Day 02b
benchmarking...
time                 1.710 ms   (1.616 ms .. 1.830 ms)
                     0.964 R²   (0.929 R² .. 0.987 R²)
mean                 1.730 ms   (1.673 ms .. 1.792 ms)
std dev              215.9 μs   (168.1 μs .. 321.3 μs)
variance introduced by outliers: 79% (severely inflated)
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]* / *[Rendered][d03h]* / *[Standalone Reflection Page][d03r]*

[d03p]: https://adventofcode.com/2021/day/3
[d03g]: https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day03.hs
[d03h]: https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day03.html
[d03r]: https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day03.md

*Reflection not yet written -- please check back later!*

### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 1.556 ms   (1.538 ms .. 1.577 ms)
                     0.998 R²   (0.997 R² .. 0.999 R²)
mean                 1.560 ms   (1.545 ms .. 1.574 ms)
std dev              58.01 μs   (47.70 μs .. 76.73 μs)
variance introduced by outliers: 25% (moderately inflated)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 543.0 μs   (527.5 μs .. 568.7 μs)
                     0.990 R²   (0.977 R² .. 0.999 R²)
mean                 534.3 μs   (527.0 μs .. 551.6 μs)
std dev              33.62 μs   (14.55 μs .. 58.08 μs)
variance introduced by outliers: 55% (severely inflated)

* parsing and formatting times excluded
```



Day 4
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day04.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d04p]* / *[Code][d04g]* / *[Rendered][d04h]* / *[Standalone Reflection Page][d04r]*

[d04p]: https://adventofcode.com/2021/day/4
[d04g]: https://github.com/mstksg/advent-of-code-2021/blob/master/src/AOC/Challenge/Day04.hs
[d04h]: https://mstksg.github.io/advent-of-code-2021/src/AOC.Challenge.Day04.html
[d04r]: https://github.com/mstksg/advent-of-code-2021/blob/master/reflections-out/day04.md

*Reflection not yet written -- please check back later!*

### Day 4 Benchmarks

```
>> Day 04a
benchmarking...
time                 298.3 μs   (296.0 μs .. 301.3 μs)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 298.2 μs   (297.3 μs .. 300.3 μs)
std dev              4.367 μs   (2.639 μs .. 7.182 μs)

* parsing and formatting times excluded

>> Day 04b
benchmarking...
time                 784.5 μs   (773.9 μs .. 805.2 μs)
                     0.997 R²   (0.994 R² .. 0.999 R²)
mean                 752.0 μs   (739.7 μs .. 773.0 μs)
std dev              53.03 μs   (40.49 μs .. 74.21 μs)
variance introduced by outliers: 59% (severely inflated)

* parsing and formatting times excluded
```

